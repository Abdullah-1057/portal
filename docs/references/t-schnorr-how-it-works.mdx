import { MarkdownChipRow } from "/src/components/Chip/MarkdownChipRow";

# Threshold Schnorr signatures reference

<MarkdownChipRow labels={["Reference"]} />

## Overview
Currently, this page (only) contains a technical specification for performing Ed25519 hierarchical key derivation.
This specification is relevant when using the Ed25519 variant of threshold Schnorr signatures on ICP.
It is, for example, of interest as reference for developers who implement libraries that perform this type of key derivation.

## Ed25519 hierarchical key derivation

This document describes a child key derivation (CKD) function for computing child public keys from parent public keys.
The document is inspired by [BIP32](https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki) and uses similar wording and structure.

### Conventions

We will assume the elliptic curve cryptography using the field and curve parameters defined by Ed25519 (see [RFC8032, Section 5.1](https://datatracker.ietf.org/doc/html/rfc8032#section-5.1)). Variables below are either:

- Integers modulo the order of the curve (referred to as n).
- Coordinates of points on the curve.
- Byte sequences.

Addition (+) of two coordinate pairs is defined as application of the EC group operation.
Concatenation (||) is the operation of appending one byte sequence onto another.

We assume the following functions:

- point(p): returns the coordinate pair resulting from EC point multiplication (repeated application of the EC group operation) of the Ed25519 base point with the integer p.
- ser<sub>P</sub>(P): serializes the coordinate pair P = (x,y) as a byte sequence using standard 32-byte compressed form (see [RFC8032, 5.1.2 Encoding](https://datatracker.ietf.org/doc/html/rfc8032#section-5.1.2)).
- utf8(s): returns the UTF-8 encoding of string s.
- parse<sub>512</sub>(p): interprets a 64-byte sequence as a 512-bit number, most significant byte first.
- HKDF(salt,IKM,info,L) -> OKM: HMAC-based key derivation function (see [RFC5869](https://datatracker.ietf.org/doc/html/rfc5869)) using HMAC-SHA512 (see [RFC4231](https://datatracker.ietf.org/doc/html/rfc4231)) calculating L-bytes long output key material (OKM) from (byte sequences) salt, input key material (IKM), and application specific information *info*.

### Extended keys

Public keys are extended with an extra 256 bits of entropy, which extension is called chain code and consists of 32 bytes.
An extended public key is represented as (K, c), with K = point(k) and c being the chain code, for some private key k.
Each extended key has 2<sub>32</sub> child keys using indices 0 through 2<sub>32</sub>-1.
We do not distinguish between hardened and non-hardenend (aka normal) child keys.

### Child key derivation (CKD) function

Given a parent extended public key and an index i, it is possible to compute the corresponding child extended public key.

The function CKDpub((K<sub>par</sub>, c<sub>par</sub>), i) â†’ (K<sub>i</sub>, c<sub>i</sub>) computes a child extended public key from a parent extended public key and an index i, where i is a byte sequence of arbitrary length (including empty):

-   let IKM = ser<sub>P</sub>(K<sub>par</sub>) || i.
-   let OKF = HKDF(c<sub>par</sub>, IKM, utf8("Ed25519"), 96).
-   Split OKF into a 64-byte and a 32-byte sequence, tweak and c<sub>i</sub>, respectively.
-   let K<sub>i</sub> = K<sub>par</sub> + point(parse<sub>512</sub>(tweak)).
-   return (K<sub>i</sub>, c<sub>i</sub>).