import { MarkdownChipRow } from "/src/components/Chip/MarkdownChipRow";

# Threshold Schnorr signatures reference

<MarkdownChipRow labels={["Reference"]} />

## Overview
Currently, this page (only) contains a technical specification for performing Ed25519 hierarchical key derivation.
This specification is relevant when using the Ed25519 variant of threshold Schnorr signatures on ICP.
It is, for example, of interest as reference for developers who implement libraries that perform this type of key derivation.

## Ed25519 hierarchical key derivation

This section describes a child key derivation (CKD) function for computing child public keys from parent public keys.
The section is inspired by [BIP32](https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki) and uses similar wording and structure.

### Motivation

To support the Ed25519 variant of threshold Schnorr signatures on the Internet Computer, a key derivation scheme compatible with Ed25519 signatures is required.
For a respective signing service on the Internet Computer to be efficient, the signing subnet maintains only a single master key pair and _derives_ signing child keys for each canister.
Although there exist various hierarchical key derivation schemes (e.g., [BIP32](https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki), [SLIP10](https://github.com/satoshilabs/slips/blob/master/slip-0010.md), [BIP32-Ed25519](https://input-output-hk.github.io/adrestia/static/Ed25519_BIP.pdf), [Schnorrkel](https://github.com/w3f/schnorrkel)), none of the analyzed schemes is suitable for the Internet Computer's (threshold) setting.
For this reason, a new derivation scheme is specified here.
The specified scheme does not make use of _clamping_ (see [RFC8032, Section 5.1.5, Item 2](https://datatracker.ietf.org/doc/html/rfc8032#section-5.1.5)), because it is unnecessary in the given setting, and satisfies the following requirements:

- Off-chain availability: New public keys can be computed off-chain from a master public key without requiring interaction with the IC.
- Hierarchical derivation: Derived keys are organized in a tree such that from any public key it is possible to derive new child keys. The first level is used to derive unique canister-specific keys from the master key.
- Compatibility: The scheme is compatible with existing standards, and it is simple to implement using existing libraries.

### Conventions

We will assume the elliptic curve cryptography using the field and curve parameters defined by Ed25519 (see [RFC8032, Section 5.1](https://datatracker.ietf.org/doc/html/rfc8032#section-5.1)). Variables below are either:

- Integers modulo the order of the curve's prime order subgroup (referred to as L).
- Coordinates of points on the curve.
- Byte sequences.

Addition (+) of two coordinate pairs is defined as application of the EC group operation.
Concatenation (||) is the operation of appending one byte sequence onto another.

We assume the following functions:

- point(p): returns the coordinate pair resulting from EC point multiplication (repeated application of the EC group operation) of the Ed25519 base point with the integer p.
- ser<sub>P</sub>(P): serializes the coordinate pair P = (x,y) as a byte sequence using standard 32-byte compressed form (see [RFC8032, 5.1.2 Encoding](https://datatracker.ietf.org/doc/html/rfc8032#section-5.1.2)).
- utf8(s): returns the UTF-8 encoding of string s.
- parse<sub>512</sub>(p): interprets a 64-byte sequence as a 512-bit number, most significant byte first.
- HKDF(salt,IKM,info,L) -> OKM: HMAC-based key derivation function (see [RFC5869](https://datatracker.ietf.org/doc/html/rfc5869)) using HMAC-SHA512 (see [RFC4231](https://datatracker.ietf.org/doc/html/rfc4231)) calculating L-bytes long output key material (OKM) from (byte sequences) salt, input key material (IKM), and application specific information *info*.

### Extended keys

Public keys are extended with an extra 256 bits of entropy, which extension is called chain code and consists of 32 bytes.
An extended public key is represented as (K, c), with K = point(k) and c being the chain code, for some private key k.
Each extended key can have an arbitrary number of child keys.
We do not distinguish between hardened and non-hardenend (aka normal) child keys.

### Child key derivation (CKD) function

Given a parent extended public key and an index i, it is possible to compute the corresponding child extended public key.

The function CKDpub((K<sub>par</sub>, c<sub>par</sub>), i) â†’ (K<sub>i</sub>, c<sub>i</sub>) computes a child extended public key from a parent extended public key and an index i, where i is a byte sequence of arbitrary length (including empty):

- let IKM = ser<sub>P</sub>(K<sub>par</sub>) || i.
- let OKM = HKDF(c<sub>par</sub>, IKM, utf8("Ed25519"), 96).
- Split OKM into a 64-byte and a 32-byte sequence, tweak and c<sub>i</sub>.
- let K<sub>i</sub> = K<sub>par</sub> + point(parse<sub>512</sub>(tweak) mod L).
- return (K<sub>i</sub>, c<sub>i</sub>).